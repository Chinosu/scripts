#! /usr/bin/env python3


from sys import argv
from abc import ABC, abstractmethod
from subprocess import run
from pathlib import Path
import os

from autotest_path import autotest_path


def main():
    try:
        module = Subcommands.match(argv[1])
        module.run()
    except:
        print_usage()

def print_usage():
    print('=x= Usage =x=')
    print()
    for usage in Subcommands.usages():
        print(usage)
    print()
    print('=x=       =x=')

class Subcommand(ABC):
    @staticmethod
    @abstractmethod
    def get_name(): pass

    @staticmethod
    @abstractmethod
    def get_usage(): pass

    @abstractmethod
    def run(self): pass

class TestModule(Subcommand):
    @staticmethod
    def get_name():
        return 'test'
    
    @staticmethod
    def get_usage():
        return 'now test [folder]'
    
    def run(self):
        folder = argv[2]
        command = [
            'python3', '-I',
            autotest_path(),
            '-E', '.',
            '-e', folder
        ]
        run(command)

class FlySubcommand(Subcommand):
    @staticmethod
    def get_name():
        return 'fly'
    
    @staticmethod
    def get_usage():
        return 'now fly [command]? [-- {subprocess args}]?'
    
    def run(self):
        make = run(['make'])
        if make.returncode != 0:
            return

        try:
            command = []

            if len(argv) > 2 and argv[2] != '--':
                command.append('./' + argv[2])
            else:
                command.append('./' + self.latest_executable_path_in_directory('.'))

            if '--' in argv:
                command += argv[argv.index('--') + 1:]

            run(command);
        except Exception as e:
            print(e)

    def latest_executable_path_in_directory(self, directory):
        directory = Path(directory)

        latest_executable_path = None
        latest_mod_time = 0

        for filename in os.listdir(directory):
            path = directory / filename
            if not path.is_file() or not os.access(path, os.X_OK): continue
            mod_time = os.path.getmtime(path)
            if mod_time > latest_mod_time:
                latest_executable_path = path
                latest_mod_time = mod_time
        
        return str(latest_executable_path)
    
class CruiseSubcommand(Subcommand):
    @staticmethod
    def get_name():
        return 'cruise'

    @staticmethod
    def get_usage():
        return 'now cruise'
    
    def run(self):
        try:
            run('./' + self.latest_executable_path_in_directory('.'))
        except Exception as e:
            print(e)

    def latest_executable_path_in_directory(self, directory):
        directory = Path(directory)

        latest_executable_path = None
        latest_mod_time = 0

        for filename in os.listdir(directory):
            path = directory / filename
            if not path.is_file() or not os.access(path, os.X_OK): continue
            mod_time = os.path.getmtime(path)
            if mod_time > latest_mod_time:
                latest_executable_path = path
                latest_mod_time = mod_time
        
        return str(latest_executable_path)

class Subcommands:
    subcommands = [TestModule, FlySubcommand, CruiseSubcommand]

    @staticmethod
    def match(name):
        for subcommand in Subcommands.subcommands:
            if subcommand.get_name() == name:
                return subcommand()
        raise KeyError(name)

    @staticmethod
    def usages():
        return [subcommand.get_usage() for subcommand in Subcommands.subcommands]

if __name__ == '__main__':
    main()